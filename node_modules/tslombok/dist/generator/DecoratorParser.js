"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.DecoratorParser = void 0;
const typescript_1 = __importStar(require("typescript"));
const MethodGeneratorDecorator_1 = require("../decorators/MethodGeneratorDecorator");
class DecoratorParser {
    decoratorRegistry;
    sourceFile;
    sourceCodePath;
    tsconfig;
    // All posible method signatures from method generator decorators
    methodSignaturesByClassName = new Map();
    constructor(sourceCode, sourceCodePath, tsconfig, decoratorRegistry) {
        this.decoratorRegistry = decoratorRegistry;
        this.sourceFile = typescript_1.default.createSourceFile('code.ts', sourceCode, typescript_1.ScriptTarget.Latest);
        this.sourceCodePath = sourceCodePath;
        this.tsconfig = tsconfig;
        this.parse();
    }
    parse() {
        const expectedDecoratorNames = this.decoratorRegistry.getDecoratorNames();
        const pathByImportName = new Map();
        typescript_1.default.forEachChild(this.sourceFile, (node) => {
            // Remember named import declaration for type reference importing
            if (typescript_1.default.isImportDeclaration(node)) {
                // Skip import without clause
                // e.g. import './foo.ts';
                if (!node.importClause)
                    return;
                // Skip default import
                // e.g. import foo './bar.ts';
                if (!node.importClause.namedBindings)
                    return;
                // Skip namepsace import
                // e.g. import * from './foor.ts';
                if (typescript_1.default.isNamespaceImport(node.importClause.namedBindings))
                    return;
                // Only `import { foo } from './bar.ts'` is acceptable
                const namedImports = node.importClause.namedBindings;
                namedImports.elements.forEach((element) => {
                    // Try to resolve module absolute path 
                    const moduleName = node.moduleSpecifier.getText(this.sourceFile).slice(1, -1);
                    const resolvedImport = typescript_1.default.resolveModuleName(moduleName, this.sourceCodePath, this.tsconfig, typescript_1.default.sys);
                    if (!resolvedImport.resolvedModule)
                        return;
                    const resolvedImportPath = resolvedImport.resolvedModule.resolvedFileName;
                    pathByImportName.set(element.name.getText(this.sourceFile), resolvedImportPath);
                });
            }
            // Traverse only class declaration node
            if (!typescript_1.default.isClassDeclaration(node))
                return;
            // TODO: support `export default class {}`
            // Don't traverse to non-module file (without named export)
            if (!node.name)
                return;
            const className = node.name.getText(this.sourceFile);
            // Traverse to the class member
            node.forEachChild((classMemberNode) => {
                // Traverse property declarations to generate `@Getter/@Setter` decorators
                if (typescript_1.default.isPropertyDeclaration(classMemberNode)) {
                    const decorators = typescript_1.default.getDecorators(classMemberNode);
                    if (!decorators)
                        return;
                    const propertyName = classMemberNode.name.getText(this.sourceFile);
                    let propertyType = classMemberNode.type;
                    if (!propertyType)
                        return; // TODO: type infer compatible
                    if (typescript_1.default.isTypeReferenceNode(propertyType)) {
                        // Skip qualified name
                        // e.g. const variable: Foo.Bar;
                        if (!typescript_1.default.isIdentifier(propertyType.typeName))
                            return;
                        const importName = propertyType.typeName.getText(this.sourceFile);
                        const importPath = pathByImportName.get(importName);
                        // Magic to import type in dts file for type reference
                        const importType = typescript_1.default.factory.createImportTypeNode(typescript_1.default.factory.createLiteralTypeNode(typescript_1.default.factory.createStringLiteral(importPath || '')), undefined, typescript_1.default.factory.createIdentifier(propertyType.getText(this.sourceFile)), undefined, false);
                        propertyType = importType;
                    }
                    for (const decorator of decorators) {
                        // Gets only TSLombok decorators
                        const decoratorName = decorator.getText(this.sourceFile).slice(1);
                        if (!expectedDecoratorNames.includes(decoratorName))
                            continue;
                        const expectedDecorator = this.decoratorRegistry.getDecorator(decoratorName);
                        if (!expectedDecorator)
                            continue;
                        if ((0, MethodGeneratorDecorator_1.isMethodGeneratorDecorator)(expectedDecorator)) {
                            if (!this.methodSignaturesByClassName.get(className)) {
                                this.methodSignaturesByClassName.set(className, []);
                            }
                            const methodSignature = expectedDecorator.createMethodSignature(propertyName, propertyType);
                            this.methodSignaturesByClassName.get(className).push(methodSignature);
                        }
                    }
                }
            });
        });
    }
    getMethodSignatures() {
        return this.methodSignaturesByClassName;
    }
}
exports.DecoratorParser = DecoratorParser;
