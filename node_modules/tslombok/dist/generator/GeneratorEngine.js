"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.GeneratorEngine = void 0;
const chokidar_1 = require("chokidar");
const fs_1 = __importDefault(require("fs"));
const glob_1 = require("glob");
const path_1 = __importDefault(require("path"));
const typescript_1 = __importDefault(require("typescript"));
const Utility_1 = require("../Utility");
const GetterDecorator_1 = require("../decorators/GetterDecorator");
const SetterDecorator_1 = require("../decorators/SetterDecorator");
const DecoratorParser_1 = require("./DecoratorParser");
const DecoratorRegistry_1 = require("./DecoratorRegistry");
const DtsGenerator_1 = require("./DtsGenerator");
class GeneratorEngine {
    // File systems
    watcher;
    watchPath;
    outputBasePath;
    // Core systems
    tsconfig;
    decoratorRegistry;
    dtsGenerator;
    constructor() {
        this.watcher = new chokidar_1.FSWatcher({ ignored: ['**/node_modules/**', '**/.git/**'] });
        this.watcher.on('change', this.onSourceCodeChange.bind(this));
        // TODO: add root path configuration
        const rootPath = process.cwd();
        this.watchPath = path_1.default.join(rootPath, '**/*.ts');
        this.outputBasePath = path_1.default.join(rootPath, '/node_modules/tslombok');
        // Load tsconfig.json file
        const tsconfigPath = typescript_1.default.findConfigFile(rootPath, typescript_1.default.sys.fileExists, 'tsconfig.json');
        if (!tsconfigPath) {
            (0, Utility_1.logTsConfigNotFound)();
            throw new Error('Cannot find tsconfig.json');
        }
        const tsconfigFile = typescript_1.default.readConfigFile(tsconfigPath, typescript_1.default.sys.readFile);
        this.tsconfig = typescript_1.default.parseJsonConfigFileContent(tsconfigFile.config, typescript_1.default.sys, rootPath).options;
        this.decoratorRegistry = new DecoratorRegistry_1.DecoratorRegistry();
        this.registerDecorators();
        this.dtsGenerator = new DtsGenerator_1.DtsGenerator(this.outputBasePath);
    }
    // Don't forget to register the complete implemented decorator
    registerDecorators() {
        this.decoratorRegistry.register(GetterDecorator_1.GetterDecorator.NAME, new GetterDecorator_1.GetterDecorator());
        this.decoratorRegistry.register(SetterDecorator_1.SetterDecorator.NAME, new SetterDecorator_1.SetterDecorator());
    }
    generate(sourceCodePaths) {
        performance.mark('generating-start');
        sourceCodePaths.forEach((sourceCodePath) => {
            const sourceCode = fs_1.default.readFileSync(sourceCodePath).toString();
            const parser = new DecoratorParser_1.DecoratorParser(sourceCode, sourceCodePath, this.tsconfig, this.decoratorRegistry);
            this.dtsGenerator.addModule(sourceCodePath, parser);
        });
        this.dtsGenerator.generate();
        performance.mark('generating-end');
        const measure = performance.measure('generating', 'generating-start', 'generating-end');
        (0, Utility_1.logSuccess)(sourceCodePaths, Math.round(measure.duration));
    }
    init() {
        const targetFiles = (0, glob_1.globSync)('**/*.ts', {
            ignore: ['node_modules/**'],
            absolute: true,
        });
        this.generate(targetFiles);
    }
    watch() {
        this.watcher.add(this.watchPath);
    }
    onSourceCodeChange(changedFilePath) {
        const posixPath = (0, Utility_1.pathToPosix)(changedFilePath);
        this.generate([posixPath]);
    }
}
exports.GeneratorEngine = GeneratorEngine;
