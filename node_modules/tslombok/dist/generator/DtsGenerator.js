"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.DtsGenerator = void 0;
const fs_1 = __importDefault(require("fs"));
const path_1 = __importDefault(require("path"));
const typescript_1 = __importStar(require("typescript"));
class DtsGenerator {
    static DTS_FILE_NAME = 'generated.d.ts';
    outputPath;
    moduleByPath;
    constructor(outputBasePath) {
        this.outputPath = path_1.default.join(outputBasePath, DtsGenerator.DTS_FILE_NAME);
        this.moduleByPath = new Map();
    }
    generate() {
        const resultFile = typescript_1.default.createSourceFile('source.ts', '', typescript_1.ScriptTarget.Latest);
        const printer = typescript_1.default.createPrinter({ newLine: typescript_1.NewLineKind.LineFeed });
        const output = printer.printList(typescript_1.ListFormat.MultiLine, this.constructDtsNodes(), resultFile);
        fs_1.default.writeFileSync(this.outputPath, output);
    }
    constructDtsNodes() {
        // Create `export {}` node, to make the dts file into a module
        const emptyNamedExport = typescript_1.default.factory.createExportDeclaration(undefined, false, typescript_1.default.factory.createNamedExports([]));
        // Create module declarations for all files that include TSLombok decorators
        const moduleDeclarations = Array.from(this.moduleByPath.values());
        return typescript_1.default.factory.createNodeArray([emptyNamedExport, ...moduleDeclarations]);
    }
    // We use the declaration merging technique to add method signatures to existing class.
    // So we need to generate interfaces and namespace with the same as class name,
    // then export them with the same module path for adding TSLombok methods.
    addModule(modulePath, decoratorParser) {
        const interfaceDeclarations = [];
        const namespaceDeclarations = [];
        const methodSignatureByClassName = decoratorParser.getMethodSignatures();
        if (methodSignatureByClassName.size === 0) {
            this.moduleByPath.delete(modulePath);
            return;
        }
        // Declare interface for non-static accessor
        for (const [className, methodSignatures] of methodSignatureByClassName) {
            const interfaceDeclaration = typescript_1.default.factory.createInterfaceDeclaration([typescript_1.default.factory.createToken(typescript_1.SyntaxKind.ExportKeyword)], className, undefined, undefined, methodSignatures);
            interfaceDeclarations.push(interfaceDeclaration);
        }
        // Declare namespace for static accessor
        // TODO: namespace for static
        // Declare module to map with sourcecode path to extends TSLombok methods
        const moduleDeclaration = typescript_1.default.factory.createModuleDeclaration([typescript_1.default.factory.createToken(typescript_1.SyntaxKind.DeclareKeyword)], typescript_1.default.factory.createStringLiteral(modulePath), typescript_1.default.factory.createModuleBlock([...interfaceDeclarations, ...namespaceDeclarations]));
        this.moduleByPath.set(modulePath, moduleDeclaration);
    }
}
exports.DtsGenerator = DtsGenerator;
