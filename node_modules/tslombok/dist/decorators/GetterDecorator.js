"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.Getter = exports.GetterDecorator = void 0;
const typescript_1 = __importDefault(require("typescript"));
const Utility_1 = require("../Utility");
// A property decorator to create a getter method dynamically up to the property name.
class GetterDecorator {
    static NAME = 'Getter';
    getClassDeclaration(...params) {
        throw new Error('Getter decorator not supported to class.');
    }
    getPropertyDeclaration(...params) {
        return (target, propertyKey) => {
            if (typeof propertyKey === 'symbol')
                propertyKey.toString();
            const propertyName = propertyKey;
            const methodName = this.getGetterName(propertyName);
            // Define getter method to the target class prototype,
            // that point to their own property instance
            Object.defineProperty(target, methodName, {
                value: function () {
                    return this[propertyName];
                },
            });
        };
    }
    createMethodSignature(propertyName, returnType) {
        return typescript_1.default.factory.createMethodSignature(undefined, // No need to have a modifer for interface in declaration merging
        this.getGetterName(propertyName), undefined, undefined, [], // No need to create parameters
        returnType);
    }
    getGetterName(propertyName) {
        return `get${(0, Utility_1.capitalize)(propertyName)}`;
    }
}
exports.GetterDecorator = GetterDecorator;
// Decorator alias
exports.Getter = new GetterDecorator().getPropertyDeclaration();
